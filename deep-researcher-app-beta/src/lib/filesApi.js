// Lightweight client for Files endpoints (backend API)
// Base: http://localhost:8000

const BASE = 'http://localhost:8000';

// Map backend fields to UI-friendly format
function normalizeFile(payload) {
    const f = payload?.file ?? payload;
    if (!f || typeof f !== 'object') return null;

    // Map io_tag to user-friendly source
    let source = 'Unknown';
    if (f.io_tag === 'uploaded') source = 'Uploaded by user';
    else if (f.io_tag === 'generated') source = 'Generated by AI';
    else if (f.io_tag === 'downloaded') source = 'Downloaded';

    // Format size from bytes
    const formatSize = (bytes) => {
        if (!bytes || bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    };

    // Safely parse date - handle invalid formats
    const parseDate = (dateStr) => {
        if (!dateStr) return '';
        try {
            // Fix malformed ISO strings like "2025-11-10T06:22:32.048609+00:00Z"
            // Remove the 'Z' if timezone offset is present
            let cleanDate = dateStr;
            if (dateStr.includes('+') && dateStr.endsWith('Z')) {
                cleanDate = dateStr.slice(0, -1); // Remove trailing Z
            }
            const date = new Date(cleanDate);
            if (isNaN(date.getTime())) {
                console.warn('Invalid date format:', dateStr);
                return '';
            }
            return date.toISOString().split('T')[0];
        } catch (err) {
            console.warn('Failed to parse date:', dateStr, err);
            return '';
        }
    };

    return {
        id: f.file_id ?? f.id,
        name: f.document_name ?? f.stored_filename ?? 'Unknown',
        storedFilename: f.stored_filename,
        size: formatSize(f.size_bytes),
        sizeBytes: f.size_bytes ?? 0,
        date: parseDate(f.date_created),
        dateCreated: f.date_created,
        type: f.mime_type ?? 'Unknown',
        mimeType: f.mime_type,
        category: f.document_type ?? 'documents',
        chat: f.chat_id ?? 'N/A',
        chatId: f.chat_id,
        user: source,
        ioTag: f.io_tag,
        typeCategory: f.type, // uploads|downloads|generated
        fileUrl: f.file_url,
        servePath: f.serve_path,
        tags: Array.isArray(f.tags) ? f.tags : [],
        content: f.content,
        contentMode: f.content_mode,
        raw: f,
    };
}

// Fetch files with optional filters
export async function fetchFiles(options = {}) {
    const {
        type,
        category,
        q,
        limit = 50,
        offset = 0,
        include_content = false,
        content_mode,
        content_limit
    } = options;

    const params = new URLSearchParams();
    if (type) params.set('type', type);
    if (category) params.set('category', category);
    if (q) params.set('q', q);
    if (limit != null) params.set('limit', String(limit));
    if (offset != null) params.set('offset', String(offset));
    if (include_content) params.set('include_content', 'true');
    if (content_mode) params.set('content_mode', content_mode);
    if (content_limit) params.set('content_limit', String(content_limit));

    const res = await fetch(`${BASE}/api/files?${params.toString()}`);
    if (!res.ok) throw new Error(`Failed to load files: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to load files');
    const list = json?.files ?? [];
    if (!Array.isArray(list)) throw new Error('Malformed files response');
    return {
        files: list.map(f => normalizeFile(f)).filter(Boolean),
        count: json?.count ?? list.length
    };
}

// Fetch a single file by ID
export async function fetchFile(fileId, options = {}) {
    const { include_content = false, content_mode, content_limit } = options;
    const params = new URLSearchParams();
    if (include_content) params.set('include_content', 'true');
    if (content_mode) params.set('content_mode', content_mode);
    if (content_limit) params.set('content_limit', String(content_limit));

    const queryString = params.toString();
    const url = `${BASE}/api/files/${encodeURIComponent(fileId)}${queryString ? '?' + queryString : ''}`;

    const res = await fetch(url);
    if (!res.ok) throw new Error(`Failed to load file: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'File not found');
    const norm = normalizeFile(json?.file ?? json);
    if (!norm) throw new Error('Malformed file response');
    return norm;
}

// Download a file
export function getDownloadUrl(fileId) {
    return `${BASE}/api/files/${encodeURIComponent(fileId)}/download`;
}

// Get file content
export async function fetchFileContent(fileId, mode = 'auto', limit) {
    const params = new URLSearchParams();
    if (mode) params.set('mode', mode);
    if (limit) params.set('limit', String(limit));

    const res = await fetch(`${BASE}/api/files/${encodeURIComponent(fileId)}/content?${params.toString()}`);
    if (!res.ok) throw new Error(`Failed to load file content: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to load content');
    return json;
}

// Upload files
export async function uploadFiles(files, metadata = {}) {
    const formData = new FormData();

    // Append files
    files.forEach(file => {
        formData.append('files', file);
    });

    // Append metadata
    if (metadata.chat_id) formData.append('chat_id', metadata.chat_id);
    if (metadata.content_description) formData.append('content_description', metadata.content_description);
    if (metadata.tags && Array.isArray(metadata.tags)) {
        formData.append('tags', JSON.stringify(metadata.tags));
    }

    const res = await fetch(`${BASE}/api/files/upload`, {
        method: 'POST',
        body: formData,
    });

    if (!res.ok) throw new Error(`Upload failed: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Upload failed');
    const list = json?.files ?? [];
    return list.map(f => normalizeFile(f)).filter(Boolean);
}

// Update file metadata
export async function updateFile(fileId, updates = {}) {
    const formData = new FormData();

    if (updates.content_description) formData.append('content_description', updates.content_description);
    if (updates.chat_id) formData.append('chat_id', updates.chat_id);
    if (updates.is_active !== undefined) formData.append('is_active', String(updates.is_active));
    if (updates.tags && Array.isArray(updates.tags)) {
        updates.tags.forEach(tag => formData.append('tags', tag));
    }

    const res = await fetch(`${BASE}/api/files/${encodeURIComponent(fileId)}`, {
        method: 'PUT',
        body: formData,
    });

    if (!res.ok) throw new Error(`Failed to update file: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to update file');
    const norm = normalizeFile(json?.file ?? json);
    if (!norm) throw new Error('Malformed file response');
    return norm;
}

// Delete a file
export async function deleteFile(fileId, hard = false) {
    const params = new URLSearchParams();
    if (hard) params.set('hard', 'true');

    const res = await fetch(`${BASE}/api/files/${encodeURIComponent(fileId)}?${params.toString()}`, {
        method: 'DELETE',
    });

    if (!res.ok) throw new Error(`Failed to delete file: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to delete file');
    return true;
}

// Get file statistics
export async function getFileStats() {
    const res = await fetch(`${BASE}/api/files/stats`);
    if (!res.ok) throw new Error(`Failed to load stats: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to load stats');
    return json?.stats ?? json;
}

// Get single file access stats
export async function getFileAccessStats(fileId, days = 30) {
    const params = new URLSearchParams({ days: String(days) });
    const res = await fetch(`${BASE}/api/files/${encodeURIComponent(fileId)}/stats?${params.toString()}`);
    if (!res.ok) throw new Error(`Failed to load file stats: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to load file stats');
    return json?.stats ?? json;
}

// Search files
export async function searchFiles(q, options = {}) {
    const { type, category, limit = 50, offset = 0 } = options;
    const params = new URLSearchParams({ q });
    if (type) params.set('type', type);
    if (category) params.set('category', category);
    if (limit != null) params.set('limit', String(limit));
    if (offset != null) params.set('offset', String(offset));

    const res = await fetch(`${BASE}/api/files/search?${params.toString()}`);
    if (!res.ok) throw new Error(`Search failed: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Search failed');
    const list = json?.files ?? json?.results ?? [];
    if (!Array.isArray(list)) throw new Error('Malformed search response');
    return {
        files: list.map(f => normalizeFile(f)).filter(Boolean),
        count: json?.count ?? list.length
    };
}

// Sync crawls from Crawl4AI
export async function syncCrawls(dryRun = false, maxImport = 200) {
    const params = new URLSearchParams();
    if (dryRun) params.set('dry_run', 'true');
    if (maxImport) params.set('max_import', String(maxImport));

    const res = await fetch(`${BASE}/api/files/sync-crawls?${params.toString()}`, {
        method: 'POST',
    });

    if (!res.ok) throw new Error(`Failed to sync crawls: ${res.status}`);
    const json = await res.json();

    if (json?.success === false) throw new Error(json?.error || 'Failed to sync crawls');
    return json;
}

// Get file serving URL
export function getFileUrl(type, filename) {
    return `${BASE}/files/${encodeURIComponent(type)}/${encodeURIComponent(filename)}`;
}
